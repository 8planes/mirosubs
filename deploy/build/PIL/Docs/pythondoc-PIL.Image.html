<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html>
<head>
<meta http-equiv='Content-Type' content='text/html; charset=us-ascii' />
<title>The PIL.Image Module</title>
<link rel='stylesheet' href='effbot.css' type='text/css' />
</head>
<body>
<h1>The PIL.Image Module</h1>
<dl>
<dt><a id='PIL.Image.blend-function' name='PIL.Image.blend-function'><b>blend(im1, im2, alpha)</b></a> [<a href='#PIL.Image.blend-function'>#</a>]</dt>
<dd>
<p>Creates a new image by interpolating between two input images, using
a constant alpha.

<pre>
   out = image1 * (1.0 - alpha) + image2 * alpha
</pre>

</p><dl>
<dt><i>im1</i></dt>
<dd>
</dd>
<dt><i>im2</i></dt>
<dd>
</dd>
<dt><i>alpha</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.composite-function' name='PIL.Image.composite-function'><b>composite(image1, image2, mask)</b></a> [<a href='#PIL.Image.composite-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>image1</i></dt>
<dd>
</dd>
<dt><i>image2</i></dt>
<dd>
</dd>
<dt><i>mask</i></dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.eval-function' name='PIL.Image.eval-function'><b>eval(image, function)</b></a> [<a href='#PIL.Image.eval-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>image</i></dt>
<dd>
</dd>
<dt><i>function</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.frombuffer-function' name='PIL.Image.frombuffer-function'><b>frombuffer(mode, size, data, decoder_name=&quot;raw&quot;, *args)</b></a> [<a href='#PIL.Image.frombuffer-function'>#</a>]</dt>
<dd>
<p>(New in 1.1.4) Creates an image memory from pixel data in a string
or byte buffer.
</p><p>
This function is similar to <a class="link" href="#PIL.Image.fromstring-function"><b>fromstring</b></a>, but uses data in
the byte buffer, where possible.  This means that changes to the
original buffer object are reflected in this image).  Not all modes
can share memory; support modes include "L", "RGBX", "RGBA", and
"CMYK".  For other modes, this function behaves like a corresponding
call to the <b>fromstring</b> function.
</p><p>
Note that this function decodes pixel data only, not entire images.
If you have an entire image file in a string, wrap it in a
<b>StringIO</b> object, and use <a class="link" href="#PIL.Image.open-function"><b>open</b></a> to load it.

</p><dl>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt><i>size</i></dt>
<dd>
</dd>
<dt><i>data</i></dt>
<dd>
</dd>
<dt><i>decoder_name</i></dt>
<dd>
</dd>
<dt><i>*args</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.fromstring-function' name='PIL.Image.fromstring-function'><b>fromstring(mode, size, data, decoder_name=&quot;raw&quot;, *args)</b></a> [<a href='#PIL.Image.fromstring-function'>#</a>]</dt>
<dd>
<p>Creates an image memory from pixel data in a string.
</p><p>
In its simplest form, this function takes three arguments
(mode, size, and unpacked pixel data).
</p><p>
You can also use any pixel decoder supported by PIL.  For more
information on available decoders, see the section <a href="pil-decoder.htm"><i>Writing Your Own File Decoder</i></a>.
</p><p>
Note that this function decodes pixel data only, not entire images.
If you have an entire image in a string, wrap it in a
<b>StringIO</b> object, and use <a class="link" href="#PIL.Image.open-function"><b>open</b></a> to load it.

</p><dl>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt><i>size</i></dt>
<dd>
</dd>
<dt><i>data</i></dt>
<dd>
</dd>
<dt><i>decoder_name</i></dt>
<dd>
</dd>
<dt><i>*args</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.getmodebandnames-function' name='PIL.Image.getmodebandnames-function'><b>getmodebandnames(mode)</b></a> [<a href='#PIL.Image.getmodebandnames-function'>#</a>]</dt>
<dd>
<p>Gets a list of individual band names.  Given a mode, this function
returns a tuple containing the names of individual bands (use
<a class="link" href="#PIL.Image.getmodetype-function"><b>getmodetype</b></a> to get the mode used to store each individual
band.

</p><dl>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
<dt>Raises <b>KeyError</b>:</dt><dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.getmodebands-function' name='PIL.Image.getmodebands-function'><b>getmodebands(mode)</b></a> [<a href='#PIL.Image.getmodebands-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
<dt>Raises <b>KeyError</b>:</dt><dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.getmodebase-function' name='PIL.Image.getmodebase-function'><b>getmodebase(mode)</b></a> [<a href='#PIL.Image.getmodebase-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
<dt>Raises <b>KeyError</b>:</dt><dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.getmodetype-function' name='PIL.Image.getmodetype-function'><b>getmodetype(mode)</b></a> [<a href='#PIL.Image.getmodetype-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
<dt>Raises <b>KeyError</b>:</dt><dd>
</dd>
</dl><br />
</dd>
<dt><b>Image()</b> (class) [<a href='#PIL.Image.Image-class'>#</a>]</dt>
<dd>
<p>This class represents an image object.</p>
<p>For more information about this class, see <a href='#PIL.Image.Image-class'><i>The Image Class</i></a>.</p>
</dd>
<dt><a id='PIL.Image.init-function' name='PIL.Image.init-function'><b>init()</b></a> [<a href='#PIL.Image.init-function'>#</a>]</dt>
<dd>
</dd>
<dt><a id='PIL.Image.isDirectory-function' name='PIL.Image.isDirectory-function'><b>isDirectory(f)</b></a> [<a href='#PIL.Image.isDirectory-function'>#</a>]</dt>
<dd>
</dd>
<dt><a id='PIL.Image.isImageType-function' name='PIL.Image.isImageType-function'><b>isImageType(t)</b></a> [<a href='#PIL.Image.isImageType-function'>#</a>]</dt>
<dd>
</dd>
<dt><a id='PIL.Image.isStringType-function' name='PIL.Image.isStringType-function'><b>isStringType(t)</b></a> [<a href='#PIL.Image.isStringType-function'>#</a>]</dt>
<dd>
</dd>
<dt><a id='PIL.Image.isTupleType-function' name='PIL.Image.isTupleType-function'><b>isTupleType(t)</b></a> [<a href='#PIL.Image.isTupleType-function'>#</a>]</dt>
<dd>
</dd>
<dt><a id='PIL.Image.merge-function' name='PIL.Image.merge-function'><b>merge(mode, bands)</b></a> [<a href='#PIL.Image.merge-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt><i>bands</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.new-function' name='PIL.Image.new-function'><b>new(mode, size, color=0)</b></a> [<a href='#PIL.Image.new-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt><i>size</i></dt>
<dd>
</dd>
<dt><i>color</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.open-function' name='PIL.Image.open-function'><b>open(file, mode=&quot;r&quot;)</b></a> [<a href='#PIL.Image.open-function'>#</a>]</dt>
<dd>
<p>Opens and identifies the given image file.
</p><p>
This is a lazy operation; this function identifies the file, but the
actual image data is not read from the file until you try to process
the data (or call the <a class="link" href="#PIL.Image.Image.load-method"><b>load</b></a> method).

</p><dl>
<dt><i>file</i></dt>
<dd>
A filename (string) or a file object.  The file object
   must implement <b>read</b>, <b>seek</b>, and <b>tell</b> methods,
   and be opened in binary mode.
</dd>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
<dt>Raises <b>IOError</b>:</dt><dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.preinit-function' name='PIL.Image.preinit-function'><b>preinit()</b></a> [<a href='#PIL.Image.preinit-function'>#</a>]</dt>
<dd>
</dd>
<dt><a id='PIL.Image.register_extension-function' name='PIL.Image.register_extension-function'><b>register_extension(id, extension)</b></a> [<a href='#PIL.Image.register_extension-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>id</i></dt>
<dd>
</dd>
<dt><i>extension</i></dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.register_mime-function' name='PIL.Image.register_mime-function'><b>register_mime(id, mimetype)</b></a> [<a href='#PIL.Image.register_mime-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>id</i></dt>
<dd>
</dd>
<dt><i>mimetype</i></dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.register_open-function' name='PIL.Image.register_open-function'><b>register_open(id, factory, accept=None)</b></a> [<a href='#PIL.Image.register_open-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>id</i></dt>
<dd>
</dd>
<dt><i>factory</i></dt>
<dd>
</dd>
<dt><i>accept</i></dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.register_save-function' name='PIL.Image.register_save-function'><b>register_save(id, driver)</b></a> [<a href='#PIL.Image.register_save-function'>#</a>]</dt>
<dd>
<dl>
<dt><i>id</i></dt>
<dd>
</dd>
<dt><i>driver</i></dt>
<dd>
</dd>
</dl><br />
</dd>
</dl>
<h2><a id='PIL.Image.Image-class' name='PIL.Image.Image-class'>The Image Class</a></h2>
<dl>
<dt><b>Image()</b> (class) [<a href='#PIL.Image.Image-class'>#</a>]</dt>
<dd>
</dd>
<dt><a id='PIL.Image.Image.convert-method' name='PIL.Image.Image.convert-method'><b>convert(mode, matrix=None)</b></a> [<a href='#PIL.Image.Image.convert-method'>#</a>]</dt>
<dd>
<p>Returns a converted copy of this image. For the "P" mode, this
method translates pixels through the palette.  If mode is
omitted, a mode is chosen so that all information in the image
and the palette can be represented without a palette.
</p><p>
The current version supports all possible conversions between
"L", "RGB" and "CMYK."
</p><p>
When translating a colour image to black and white (mode "L"),
the library uses the ITU-R 601-2 luma transform:
</p><p>
<b>L = R * 299/1000 + G * 587/1000 + B * 114/1000</b>
</p><p>
When translating a greyscale image into a bilevel image (mode
"1"), all non-zero values are set to 255 (white). To use other
thresholds, use the <a class="link" href="#PIL.Image.Image.point-method"><b>point</b></a> method.

</p><dl>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt><i>matrix</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.copy-method' name='PIL.Image.Image.copy-method'><b>copy()</b></a> [<a href='#PIL.Image.Image.copy-method'>#</a>]</dt>
<dd>
<dl>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.crop-method' name='PIL.Image.Image.crop-method'><b>crop(box=None)</b></a> [<a href='#PIL.Image.Image.crop-method'>#</a>]</dt>
<dd>
<p>Returns a rectangular region from this image. The box is a
4-tuple defining the left, upper, right, and lower pixel
coordinate.
</p><p>
This is a lazy operation.  Changes to the source image may or
may not be reflected in the cropped image.  To break the
connection, call the <a class="link" href="#PIL.Image.Image.load-method"><b>load</b></a> method on the cropped
copy.

</p><dl>
<dt><i>The</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.draft-method' name='PIL.Image.Image.draft-method'><b>draft(mode, size)</b></a> [<a href='#PIL.Image.Image.draft-method'>#</a>]</dt>
<dd>
<p>Configures the image file loader so it returns a version of the
image that as closely as possible matches the given mode and
size.  For example, you can use this method to convert a colour
JPEG to greyscale while loading it, or to extract a 128x192
version from a PCD file.
</p><p>
Note that this method modifies the Image object in place.  If
the image has already been loaded, this method has no effect.

</p><dl>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt><i>size</i></dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.filter-method' name='PIL.Image.Image.filter-method'><b>filter(filter)</b></a> [<a href='#PIL.Image.Image.filter-method'>#</a>]</dt>
<dd>
<p>Filters this image using the given filter.  For a list of
available filters, see the <b>ImageFilter</b> module.

</p><dl>
<dt><i>filter</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.fromstring-method' name='PIL.Image.Image.fromstring-method'><b>fromstring(data, decoder_name=&quot;raw&quot;, *args)</b></a> [<a href='#PIL.Image.Image.fromstring-method'>#</a>]</dt>
<dd>
<p>Loads this image with pixel data from a string.
</p><p>
This method is similar to the <a class="link" href="#PIL.Image.fromstring-function"><b>fromstring</b></a> function, but
loads data into this image instead of creating a new image
object.
</p></dd>
<dt><a id='PIL.Image.Image.getbands-method' name='PIL.Image.Image.getbands-method'><b>getbands()</b></a> [<a href='#PIL.Image.Image.getbands-method'>#</a>]</dt>
<dd>
<p>Returns a tuple containing the name of each band in this image.
For example, <b>getbands</b> on an RGB image returns ("R", "G", "B").

</p><dl>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.getbbox-method' name='PIL.Image.Image.getbbox-method'><b>getbbox()</b></a> [<a href='#PIL.Image.Image.getbbox-method'>#</a>]</dt>
<dd>
<dl>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.getcolors-method' name='PIL.Image.Image.getcolors-method'><b>getcolors(maxcolors=256)</b></a> [<a href='#PIL.Image.Image.getcolors-method'>#</a>]</dt>
<dd>
<dl>
<dt><i>maxcolors</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.getdata-method' name='PIL.Image.Image.getdata-method'><b>getdata(band=None)</b></a> [<a href='#PIL.Image.Image.getdata-method'>#</a>]</dt>
<dd>
<p>Returns the contents of this image as a sequence object
containing pixel values.  The sequence object is flattened, so
that values for line one follow directly after the values of
line zero, and so on.
</p><p>
Note that the sequence object returned by this method is an
internal PIL data type, which only supports certain sequence
operations.  To convert it to an ordinary sequence (e.g. for
printing), use <b>list(im.getdata())</b>.

</p><dl>
<dt><i>band</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.getextrema-method' name='PIL.Image.Image.getextrema-method'><b>getextrema()</b></a> [<a href='#PIL.Image.Image.getextrema-method'>#</a>]</dt>
<dd>
<dl>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.getim-method' name='PIL.Image.Image.getim-method'><b>getim()</b></a> [<a href='#PIL.Image.Image.getim-method'>#</a>]</dt>
<dd>
<dl>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.getpalette-method' name='PIL.Image.Image.getpalette-method'><b>getpalette()</b></a> [<a href='#PIL.Image.Image.getpalette-method'>#</a>]</dt>
<dd>
<dl>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.getpixel-method' name='PIL.Image.Image.getpixel-method'><b>getpixel(xy)</b></a> [<a href='#PIL.Image.Image.getpixel-method'>#</a>]</dt>
<dd>
<dl>
<dt><i>xy</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.getprojection-method' name='PIL.Image.Image.getprojection-method'><b>getprojection()</b></a> [<a href='#PIL.Image.Image.getprojection-method'>#</a>]</dt>
<dd>
<dl>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.histogram-method' name='PIL.Image.Image.histogram-method'><b>histogram(mask=None)</b></a> [<a href='#PIL.Image.Image.histogram-method'>#</a>]</dt>
<dd>
<p>Returns a histogram for the image. The histogram is returned as
a list of pixel counts, one for each pixel value in the source
image. If the image has more than one band, the histograms for
all bands are concatenated (for example, the histogram for an
"RGB" image contains 768 values).
</p><p>
A bilevel image (mode "1") is treated as a greyscale ("L") image
by this method.
</p><p>
If a mask is provided, the method returns a histogram for those
parts of the image where the mask image is non-zero. The mask
image must have the same size as the image, and be either a
bi-level image (mode "1") or a greyscale image ("L").

</p><dl>
<dt><i>mask</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.load-method' name='PIL.Image.Image.load-method'><b>load()</b></a> [<a href='#PIL.Image.Image.load-method'>#</a>]</dt>
<dd>
<dl>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.offset-method' name='PIL.Image.Image.offset-method'><b>offset(xoffset, yoffset=None)</b></a> [<a href='#PIL.Image.Image.offset-method'>#</a>]</dt>
<dd>
<p>(Deprecated) Returns a copy of the image where the data has been
offset by the given distances. Data wraps around the edges. If
yoffset is omitted, it is assumed to be equal to xoffset.
</p><p>
This method is deprecated. New code should use the <b>offset</b>
function in the <b>ImageChops</b> module.

</p><dl>
<dt><i>xoffset</i></dt>
<dd>
</dd>
<dt><i>yoffset</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.paste-method' name='PIL.Image.Image.paste-method'><b>paste(im, box=None, mask=None)</b></a> [<a href='#PIL.Image.Image.paste-method'>#</a>]</dt>
<dd>
<p>Pastes another image into this image. The box argument is either
a 2-tuple giving the upper left corner, a 4-tuple defining the
left, upper, right, and lower pixel coordinate, or None (same as
(0, 0)).  If a 4-tuple is given, the size of the pasted image
must match the size of the region.
</p><p>
If the modes don't match, the pasted image is converted to the
mode of this image (see the <a class="link" href="#PIL.Image.Image.convert-method"><b>convert</b></a> method for
details).
</p><p>
Instead of an image, the source can be a integer or tuple
containing pixel values.  The method then fills the region
with the given colour.  When creating RGB images, you can
also use colour strings as supported by the ImageColor module.
</p><p>
If a mask is given, this method updates only the regions
indicated by the mask.  You can use either "1", "L" or "RGBA"
images (in the latter case, the alpha band is used as mask).
Where the mask is 255, the given image is copied as is.  Where
the mask is 0, the current value is preserved.  Intermediate
values can be used for transparency effects.
</p><p>
Note that if you paste an "RGBA" image, the alpha band is
ignored.  You can work around this by using the same image as
both source image and mask.

</p><dl>
<dt><i>im</i></dt>
<dd>
</dd>
<dt><i>box</i></dt>
<dd>
<p>An optional 4-tuple giving the region to paste into.
   If a 2-tuple is used instead, it's treated as the upper left
   corner.  If omitted or None, the source is pasted into the
   upper left corner.
   </p><p>
   If an image is given as the second argument and there is no
   third, the box defaults to (0, 0), and the second argument
   is interpreted as a mask image.
</p></dd>
<dt><i>mask</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.point-method' name='PIL.Image.Image.point-method'><b>point(lut, mode=None)</b></a> [<a href='#PIL.Image.Image.point-method'>#</a>]</dt>
<dd>
<dl>
<dt><i>lut</i></dt>
<dd>
</dd>
<dt><i>mode</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.putalpha-method' name='PIL.Image.Image.putalpha-method'><b>putalpha(alpha)</b></a> [<a href='#PIL.Image.Image.putalpha-method'>#</a>]</dt>
<dd>
<dl>
<dt><i>im</i></dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.putdata-method' name='PIL.Image.Image.putdata-method'><b>putdata(data, scale=1.0, offset=0.0)</b></a> [<a href='#PIL.Image.Image.putdata-method'>#</a>]</dt>
<dd>
<p>Copies pixel data to this image.  This method copies data from a
sequence object into the image, starting at the upper left
corner (0, 0), and continuing until either the image or the
sequence ends.  The scale and offset values are used to adjust
the sequence values: <b>pixel = value*scale + offset</b>.

</p><dl>
<dt><i>data</i></dt>
<dd>
</dd>
<dt><i>scale</i></dt>
<dd>
</dd>
<dt><i>offset</i></dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.putpalette-method' name='PIL.Image.Image.putpalette-method'><b>putpalette(data)</b></a> [<a href='#PIL.Image.Image.putpalette-method'>#</a>]</dt>
<dd>
<dl>
<dt><i>data</i></dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.putpixel-method' name='PIL.Image.Image.putpixel-method'><b>putpixel(xy, value)</b></a> [<a href='#PIL.Image.Image.putpixel-method'>#</a>]</dt>
<dd>
<p>Modifies the pixel at the given position. The colour is given as
a single numerical value for single-band images, and a tuple for
multi-band images.
</p><p>
Note that this method is relatively slow.  For more extensive
changes, use <a class="link" href="#PIL.Image.Image.paste-method"><b>paste</b></a> or the <b>ImageDraw</b> module
instead.

</p><dl>
<dt><i>xy</i></dt>
<dd>
</dd>
<dt><i>value</i></dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.resize-method' name='PIL.Image.Image.resize-method'><b>resize(size, filter=NEAREST)</b></a> [<a href='#PIL.Image.Image.resize-method'>#</a>]</dt>
<dd>
<dl>
<dt><i>size</i></dt>
<dd>
</dd>
<dt><i>filter</i></dt>
<dd>
An optional resampling filter.  This can be
   one of <b>NEAREST</b> (use nearest neighbour), <b>BILINEAR</b>
   (linear interpolation in a 2x2 environment), <b>BICUBIC</b>
   (cubic spline interpolation in a 4x4 environment), or
   <b>ANTIALIAS</b> (a high-quality downsampling filter).
   If omitted, or if the image has mode "1" or "P", it is
   set <b>NEAREST</b>.
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.rotate-method' name='PIL.Image.Image.rotate-method'><b>rotate(angle, filter=NEAREST)</b></a> [<a href='#PIL.Image.Image.rotate-method'>#</a>]</dt>
<dd>
<dl>
<dt><i>angle</i></dt>
<dd>
</dd>
<dt><i>filter</i></dt>
<dd>
An optional resampling filter.  This can be
   one of <b>NEAREST</b> (use nearest neighbour), <b>BILINEAR</b>
   (linear interpolation in a 2x2 environment), or <b>BICUBIC</b>
   (cubic spline interpolation in a 4x4 environment).
   If omitted, or if the image has mode "1" or "P", it is
   set <b>NEAREST</b>.
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.save-method' name='PIL.Image.Image.save-method'><b>save(file, format=None, **options)</b></a> [<a href='#PIL.Image.Image.save-method'>#</a>]</dt>
<dd>
<p>Saves this image under the given filename.  If no format is
specified, the format to use is determined from the filename
extension, if possible.
</p><p>
Keyword options can be used to provide additional instructions
to the writer. If a writer doesn't recognise an option, it is
silently ignored. The available options are described later in
this handbook.
</p><p>
You can use a file object instead of a filename. In this case,
you must always specify the format. The file object must
implement the <b>seek</b>, <b>tell</b>, and <b>write</b>
methods, and be opened in binary mode.

</p><dl>
<dt><i>file</i></dt>
<dd>
</dd>
<dt><i>format</i></dt>
<dd>
</dd>
<dt><i>**options</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
<dt>Raises <b>KeyError</b>:</dt><dd>
</dd>
<dt>Raises <b>IOError</b>:</dt><dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.seek-method' name='PIL.Image.Image.seek-method'><b>seek(frame)</b></a> [<a href='#PIL.Image.Image.seek-method'>#</a>]</dt>
<dd>
<p>Seeks to the given frame in this sequence file. If you seek
beyond the end of the sequence, the method raises an
<b>EOFError</b> exception. When a sequence file is opened, the
library automatically seeks to frame 0.
</p><p>
Note that in the current version of the library, most sequence
formats only allows you to seek to the next frame.

</p><dl>
<dt><i>frame</i></dt>
<dd>
</dd>
<dt>Raises <b>EOFError</b>:</dt><dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.show-method' name='PIL.Image.Image.show-method'><b>show(title=None)</b></a> [<a href='#PIL.Image.Image.show-method'>#</a>]</dt>
<dd>
<p>Displays this image. This method is mainly intended for
debugging purposes.
</p><p>
On Unix platforms, this method saves the image to a temporary
PPM file, and calls the <b>xv</b> utility.
</p><p>
On Windows, it saves the image to a temporary BMP file, and uses
the standard BMP display utility to show it (usually Paint).

</p><dl>
<dt><i>title</i></dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.split-method' name='PIL.Image.Image.split-method'><b>split()</b></a> [<a href='#PIL.Image.Image.split-method'>#</a>]</dt>
<dd>
<dl>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.tell-method' name='PIL.Image.Image.tell-method'><b>tell()</b></a> [<a href='#PIL.Image.Image.tell-method'>#</a>]</dt>
<dd>
<dl>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.thumbnail-method' name='PIL.Image.Image.thumbnail-method'><b>thumbnail(size, resample=NEAREST)</b></a> [<a href='#PIL.Image.Image.thumbnail-method'>#</a>]</dt>
<dd>
<p>Make this image into a thumbnail.  This method modifies the
image to contain a thumbnail version of itself, no larger than
the given size.  This method calculates an appropriate thumbnail
size to preserve the aspect of the image, calls the <a class="link" href="#PIL.Image.Image.draft-method"><b>draft</b></a> method to configure the file reader (where
applicable), and finally resizes the image.
</p><p>
Note that the bilinear and bicubic filters in the current
version of PIL are not well-suited for thumbnail generation.
You should use <b>ANTIALIAS</b> unless speed is much more
important than quality.
</p><p>
Also note that this function modifies the Image object in place.
If you need to use the full resolution image as well, apply this
method to a <a class="link" href="#PIL.Image.Image.copy-method"><b>copy</b></a> of the original image.

</p><dl>
<dt><i>size</i></dt>
<dd>
</dd>
<dt><i>resample</i></dt>
<dd>
Optional resampling filter.  This can be one
   of <b>NEAREST</b>, <b>BILINEAR</b>, <b>BICUBIC</b>, or
   <b>ANTIALIAS</b> (best quality).  If omitted, it defaults
   to <b>NEAREST</b> (this will be changed to ANTIALIAS in a
   future version).
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.tobitmap-method' name='PIL.Image.Image.tobitmap-method'><b>tobitmap(name=&quot;image&quot;)</b></a> [<a href='#PIL.Image.Image.tobitmap-method'>#</a>]</dt>
<dd>
<dl>
<dt><i>name</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
<dt>Raises <b>ValueError</b>:</dt><dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.tostring-method' name='PIL.Image.Image.tostring-method'><b>tostring(encoder_name=&quot;raw&quot;, *args)</b></a> [<a href='#PIL.Image.Image.tostring-method'>#</a>]</dt>
<dd>
<dl>
<dt><i>encoder_name</i></dt>
<dd>
</dd>
<dt><i>*args</i></dt>
<dd>
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.transform-method' name='PIL.Image.Image.transform-method'><b>transform(size, method, data, resample=NEAREST)</b></a> [<a href='#PIL.Image.Image.transform-method'>#</a>]</dt>
<dd>
<p>Transforms this image.  This method creates a new image with the
given size, and the same mode as the original, and copies data
to the new image using the given transform.
</p><p>
</p><dl>
<dt><i>size</i></dt>
<dd>
</dd>
<dt><i>method</i></dt>
<dd>
The transformation method.  This is one of
  <b>EXTENT</b> (cut out a rectangular subregion), <b>AFFINE</b>
  (affine transform), <b>PERSPECTIVE</b> (perspective
  transform), <b>QUAD</b> (map a quadrilateral to a
  rectangle), or <b>MESH</b> (map a number of source quadrilaterals
  in one operation).
</dd>
<dt><i>data</i></dt>
<dd>
</dd>
<dt><i>resample</i></dt>
<dd>
Optional resampling filter.  It can be one of
   <b>NEAREST</b> (use nearest neighbour), <b>BILINEAR</b>
   (linear interpolation in a 2x2 environment), or
   <b>BICUBIC</b> (cubic spline interpolation in a 4x4
   environment). If omitted, or if the image has mode
   "1" or "P", it is set to <b>NEAREST</b>.
</dd>
<dt>Returns:</dt>
<dd>
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.transpose-method' name='PIL.Image.Image.transpose-method'><b>transpose(method)</b></a> [<a href='#PIL.Image.Image.transpose-method'>#</a>]</dt>
<dd>
<dl>
<dt><i>method</i></dt>
<dd>
One of <b>FLIP_LEFT_RIGHT</b>, <b>FLIP_TOP_BOTTOM</b>,
<b>ROTATE_90</b>, <b>ROTATE_180</b>, or <b>ROTATE_270</b>.
</dd>
</dl><br />
</dd>
<dt><a id='PIL.Image.Image.verify-method' name='PIL.Image.Image.verify-method'><b>verify()</b></a> [<a href='#PIL.Image.Image.verify-method'>#</a>]</dt>
<dd>
</dd>
</dl>
</body></html>
